#!/usr/local/bin/node

var fs = require('fs');
var spawn = require('child_process').spawn;
var queue = require('q');

var config = null;

var ursa = require('ursa');


var action = process.argv[2];
switch(action) {

    case 'encrypt':
        queue().
        then(function loadConfig() {
            var deferred = queue.defer();
            fs.readFile('config.json', function(err, data) {
                deferred.resolve(JSON.parse(data));
                config = JSON.parse(data);
            });
            return deferred.promise;
        }).
        then(function startEnryption() {
            var publicKeyQueue = queue();
            for (var i = 0; i < config.collaborators.length; i++) {
                var collaborator = config.collaborators[i];

                publicKeyQueue = publicKeyQueue.
                    then(startEncryption(config, collaborator));
            }

            publicKeyQueue.then(function() {
                console.log('publicKeyQueue done!')
                deferred.resolve();
            });

            return deferred.promise;
        });

        break;

    case 'decrypt':
        var user = process.argv[3];

        queue().
        then(function loadConfig() {
            var deferred = queue.defer();
            fs.readFile('config.json', function(err, data) {
                deferred.resolve(JSON.parse(data));
                config = JSON.parse(data);
            });
            return deferred.promise;
        }).
        then(startDecryption(user));

        break;

    default:
        console.log('use either decrypt or encrypt');

}

function startEncryption(config, collaborator) {
    return function (){
        var deferred = queue.defer();

        var encryptionQueue = queue();

        for (var i = 0; i < config.files.length; i++) {
            var file = config.files[i];

            encryptionQueue = encryptionQueue.then(encrypt(file, collaborator));

        };

        encryptionQueue.then(function() {
            console.log('all done!');
            deferred.resolve();
        });

        return deferred.promise;
    }
}

function startDecryption(user) {
    return function (config){
        var deferred = queue.defer();

        var decryptionQueue = queue();

        for (var i = 0; i < config.collaborators.length; i++) {
            var collaborator = config.collaborators[i];
            if(collaborator.name === user) {
                break;
            }
        };

        for (var i = 0; i < config.files.length; i++) {
            var file = config.files[i];

            decryptionQueue = decryptionQueue.then(decrypt(file, collaborator));

        };

        decryptionQueue.then(function() {
            console.log('all done!');
            deferred.resolve();
        });

        return deferred.promise;
    }
}

function encrypt(file, collaborator) {
    return function() {
        var deferred = queue.defer();
        console.log('encrypting for ' + collaborator.name);

        fs.readFile(file, function(err, data) {

            var crt = ursa.createPublicKey(collaborator.publicKey);

            var encrypted = crt.encrypt(data);
            fs.writeFile(file + '.' + collaborator.name + '.crypt', encrypted, deferred.makeNodeResolver());
        });

        return deferred.promise;
    }
}

function decrypt(file, collaborator) {

    var filename = file + '.' + collaborator.name + '.crypt';

    fs.readFile(filename, function(err, input) {

        fs.readFile(collaborator.privateKey, function(err, key) {

            var key = ursa.createPrivateKey(key.toString());
            var decrypted = key.decrypt(input);

            fs.writeFile(file, decrypted, function() {
                console.log('done decrypting file!');
            });
        });

    });
}