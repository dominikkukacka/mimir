#!/usr/local/bin/node

var fs = require('fs');
var spawn = require('child_process').spawn;
var queue = require('q');

var config = {
    files: [],
    collaborators: []
};

var ursa = require('./ursa/ursa');

var action = process.argv[2];
switch(action) {

    case 'collaborators':

        var subaction = process.argv[3];

        switch(subaction) {
            case 'delete':
            case 'remove':
            case 'rm':
                var name = process.argv[4];
                if(!name) {
                    console.error('please specify a name');
                    return;
                }

                deleteCollaborator(name);

                break;

            case 'create':
            case 'new':
            case 'add':
                var name = process.argv[4];
                if(!name) {
                    console.error('please specify a name');
                    return;
                }

                var privateKey = process.argv[5];
                if(!privateKey) {
                    console.error('please specify a privateKey');
                    return;
                }

                var publicKey = process.argv[6];
                if(!publicKey) {
                    console.error('please specify a publicKey');
                    return;
                }

                addCollaborator(name, privateKey, publicKey);

                break;

            case 'list':
            default:
                listCollaborators();
                break;
        }


        break;

    case 'encrypt':

        queue().
            then(loadConfig()).
            then(function() {
                var deferred = queue.defer();

                var publicKeyQueue = queue().then(loadConfig());
                for (var i = 0; i < config.collaborators.length; i++) {
                    var collaborator = config.collaborators[i];

                    publicKeyQueue = publicKeyQueue.
                        then(startEncryption(config, collaborator));
                }

                publicKeyQueue.then(function() {
                    console.log('all encrypted')
                    deferred.resolve();
                });

                deferred.resolve();
            });

        break;

    case 'decrypt':
        var user = process.argv[3];

        queue().
            then(loadConfig()).
            then(startDecryption(config, user)).
            then(function() {
                console.log('all decrypted');
            })

    default:
        console.log('use either decrypt or encrypt');

}

function saveConfig() {
    return function() {
        var deferred = queue.defer();
        fs.writeFile('config.json', JSON.stringify(config, null, 4), deferred.makeNodeResolver());
        return deferred.promise;
    }
}


function addCollaborator(name, privateKey, publicKey) {
    queue().
        then(loadConfig()).
        then(function() {
            var deferred = queue.defer();
            // console.log('adding', name, privateKey, publicKey);
            fs.readFile(publicKey, function(err, data) {

                var crt = ursa.openSshPublicKey(data.toString());

                var publicKeyString = crt.toPublicPem().toString();
                var collaborator = {
                    name: name,
                    privateKey: privateKey,
                    publicKey: publicKeyString
                };

                config.collaborators.push(collaborator);
                deferred.resolve();
            });

            return deferred.promise;
        }).
        then(saveConfig()).
        then(function() {
            console.log('collaborator added');
        })
}

function deleteCollaborator(name) {
    queue().
        then(loadConfig()).
        then(function() {
            var newCollaborators = config.collaborators.filter(function(collaborator) {
                return collaborator.name !== name;
            });

            config.collaborators = newCollaborators;
        }).
        then(saveConfig()).
        then(function() {
            console.log('collaborator removed');
        })
}

function listCollaborators() {
    queue().
        then(loadConfig()).
        then(function() {
            var names = config.collaborators.map(function(collaborator) {
                return collaborator.name
            });

            console.log('Known collaborators:');
            console.log('  - ' + names.join("\n  - "));
        });
}

function loadConfig() {
    return function() {
        var deferred = queue.defer();

        fs.readFile('config.json', function(err, data) {
            if(err) {
                // config does not exist -> create it
                saveConfig();
            } else {
                config = JSON.parse(data);
            }
            deferred.resolve(config);
        });

        return deferred.promise;
    }
}

function startEncryption(config, collaborator) {
    return function (){
        var deferred = queue.defer();

        var encryptionQueue = queue();

        for (var i = 0; i < config.files.length; i++) {
            var file = config.files[i];

            encryptionQueue = encryptionQueue.then(encrypt(file, collaborator));

        };

        encryptionQueue.then(function() {
            console.log('all done!');
            deferred.resolve();
        });

        return deferred.promise;
    }
}

function startDecryption(config, user) {
    var deferred = queue.defer();

    var decryptionQueue = queue();

    for (var i = 0; i < config.collaborators.length; i++) {
        var collaborator = config.collaborators[i];
        if(collaborator.name === user) {
            break;
        }
    };

    for (var i = 0; i < config.files.length; i++) {
        var file = config.files[i];

        decryptionQueue = decryptionQueue.then(decrypt(file, collaborator));

    };

    decryptionQueue.then(function() {
        deferred.resolve();
    });

    return deferred.promise;
}

function encrypt(file, collaborator) {
    return function() {
        var deferred = queue.defer();
        console.log('encrypting for ' + collaborator.name);

        fs.readFile(file, function(err, data) {
            if(err) {
                console.error(err);
                deferred.reject();
            }
            var crt = ursa.createPublicKey(collaborator.publicKey);

            var encrypted = crt.encrypt(data);
            fs.writeFile(file + '.' + collaborator.name + '.crypt', encrypted, deferred.makeNodeResolver());
        });

        return deferred.promise;
    }
}

function decrypt(file, collaborator) {

    var filename = file + '.' + collaborator.name + '.crypt';

    fs.readFile(filename, function(err, input) {

        fs.readFile(collaborator.privateKey, function(err, key) {

            var key = ursa.createPrivateKey(key.toString());
            var decrypted = key.decrypt(input);

            fs.writeFile(file, decrypted, function() {
                console.log('done decrypting file!');
            });
        });

    });
}